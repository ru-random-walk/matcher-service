# matcher-service
Подбор пользователей для прогулки исходя из предпочтений, наличия пользователя в группе. Хранение и менеджмент пользовательских «анкет», в которых описаны их предпочтения (через группы)

---
### Функциональные требования:

- поиск наиболее подходящих для прогулки пользователей среди ближайших
    - Фильтрация подходящих пользователей по группам
    - Быстрый поиск без фильтров
- Хранит все данные о пользовательских характеристиках(пол, возраст, координаты, список групп), на основе которых предлагает кандидатов
- Сервис должен гарантировать пользователю поиск кандидата, даже если уже найденый кандидат откажется от прогулки
- Должен быть всегда способен найти партнера для прогулки (даже если он находится на большом расстоянии, если пользователь это расстояние не ограничил)
- Хранит историю прогулок
- Отправка запроса на прогулку пользователю, с которым уже была прогулка

---
### Доменная модель

![matcher_service_domain_sql_prototype drawio-2](https://github.com/user-attachments/assets/70dae352-6ac1-4977-8fc7-95388944eb11)

---
### Алгоритм подбора
П1 - текущий пользователь, управляющий приложением
П2 - подобранный для П1 пользователь
WALK_TIME = время которое отводится на прогулку, пока = 1 час
Счетчик встреч задается пользователем перед началом подбора, счетчик задается для каждого дня, он не может быть больше (заданного интервала доступа определенного дня / 1.5ч) 

П1 задает свои окна доступа, кол-во прогулок для каждого дня из окон доступа (если не передано, то берем = 2, если максимум позволяет), вид фильтров по группам, сами группы для фильтра и радиус поиска П2. Нажимает кнопку поиска
Фильтры по группам двух видов: все подходят(ALL_MATCH)/хотя бы один подходит(ANY_MATCH)

0. Для П1 проверяем, что переданные окна доступа не пересекаются с текущими встречами, если пересечение есть, то отправляем ошибку. Также провреяем что окна доступа валидны (from < to)
1. Для П1 ищется список встреч удовлетворяющих по радиусу, виду фильтра, группам из фильтра и статусу встречи = "IN_SEARCH":
- если вид=ALL_MATCH, то все группы из фильтра П1 должны быть = всем группам из фильтров встречи, ранее созданной П2
- если вид=ANY_MATCH, то хотя бы одна группа из фильтра П1 должна быть в фильтре групп из встречи, ранее созданной П2

2. Для найденных в (1) встреч проверяем окна доступа. 

2.1. Если окна встречи накладываются друг на друга (допустим, П1 доступен с 12 до 17, а П2 c 15 до 16), то привязываем П1 к ранее созданной П2 встрече. Выставляем у этой встречи starts_at = минимальными доступными дате и времени наложения окон доступа. 

2.2  В заявке меняем статус встречи на "APPOINTED"

2.3 Для П1 создаем заявку на встречу в статусе IN_SEARCH с фильтрами и окнами доступа из запроса, за исключением окна доступа уже назначенной с П2 встречи (разделяем интервал времени, если необходимо, на [время до dateFrom; dateFrom] и [dateFrom + WALK_TIME; время после dateFrom + WALK_TIME]), для дня назначенной встречи должны убавить значения счетчика встреч. _Если у П1 выставлен только один день и счетчик встреч в этот день был = 1, то заявку не создаем_. 

2.4  Делим заявку П2: создаем для П2 новую заявку на прогулку, перенося туда всю информацию из прошлой заявки, по аналогии с П1 в пункте (2.3)

2.5  Информацию об окнах доступа заявки П2 в статусе APPOINTED удаляем (ставим null).

2.6  Отправляем запрос на создание чата в Chat-Service

3. Если окна встречи не накладываются ни с одной заявкой, то создаем заявку на прогулку для П1. Записываем туда: ID П1, координаты П1, вид фильтра по группам, список групп из фильтра, окна доступа П1, статус заявки ставим = IN_SEARCH, created_at = текущее время . -- **Конец алгоритма** 


Пример передаваемого json для окон доступа:
```
{
    "availableTime": [
        {
            "date": "27.10.2024",
            "walkCount": 3,
            "timeWindows": [
                {
                    "from": "11:00",
                    "to": "19:00"
                },
                {
                    "from": "21:00",
                    "to": "23:00"
                }
            ]
        },
        {
            "date": "28.10.2024",
            "walkCount": 1,
            "timeWindows": [
                {
                    "from": "11:00",
                    "to": "13:00"
                }
            ]
        }
    ]
}
```
